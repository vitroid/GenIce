# テストの進め方（方針とベストプラクティス）

新機能を追加するたびに、体系的にテストを追加・実行するための指針です。

## 1. テストの種類を分ける（テストピラミッド）

役割ごとに次のように分けると整理しやすいです。

| 階層               | 場所             | 役割                                 | 新機能で増やすもの                                           |
| ------------------ | ---------------- | ------------------------------------ | ------------------------------------------------------------ |
| **単体**           | `unittest/`      | プラグイン・モジュール単体の振る舞い | 新しい関数・クラス・プラグイン種別ごとに `test_*.py`         |
| **結合**           | `combined/` など | CLI 実行や複数モジュールの連携       | 新オプション・新フォーマットの「実行して出力が変わる」テスト |
| **リグレッション** | `combined/`      | バージョン間で同じ入力 → 同じ出力    | 新機能を組み込んだケースを combined のケース一覧に追加       |

「新機能を追加したら、そのレベルに応じてこの 3 つのどれか（または複数）にテストを 1 本足す」と決めておくと体系的になります。

## 2. 単体テストのベストプラクティス（pytest 前提）

- **1 モジュール／1 機能 ≒ 1 テストファイル**  
  例: 新しく `genice2/foo/bar.py` を足した → `tests/unittest/test_bar.py` を追加。

- **ファイル・関数名のルール**

  - ファイル: `test_*.py`
  - テスト関数: `test_<何を>_<条件>_<期待結果>` のように説明的にする。

- **1 テスト関数 = 1 つの「主張」**  
  複数 assert より「1 シナリオ 1assert」を心がけると、失敗時の原因が分かりやすい。

- **重い準備は fixture にまとめる**  
  `unittest/Makefile` のように genice でサンプルファイルを生成する部分は、`conftest.py` の `@pytest.fixture` にすると、複数テストで使い回せる。

- **新プラグイン種別を増やした場合**  
  `unittest/` に `test_<種類>.py` を 1 本追加し、`test_lattice.py` と同様に `scan` → `safe_import` で全プラグインを列挙し、必須属性があるか・例外なくロードできるかをテストする。そうすると「追加のたびに 1 プラグイン分だけ自動で検証される」状態を保てる。

## 3. 新機能追加時のチェックリスト（運用ルール）

「新機能を入れたら必ずやること」を決めておくと、テストが散らかりにくい。

1. **振る舞いの核（1 関数・1 クラス）**  
   → `tests/unittest/test_<モジュール名>.py` に、その振る舞いを検証する `test_*` を 1 つ以上追加。

2. **新オプション・新フォーマット・新 lattice**  
   → 「全プラグインを回す」系テストがあれば、そこに含まれるか確認。必要なら `plugins["tests"]` にオプション付きケースを追加（既存の lattice テストのオプション扱いと同じ考え方）。

3. **CLI の挙動（オプションや出力形式）**  
   → `combined/` の「CLI を実行してファイル比較」の仕組みに、新オプション／新フォーマット用のケースを 1 つ追加（テストケース自動生成スクリプトがあれば、その入力リストに 1 行足す）。

4. **破壊的変更やバグ修正**  
   → 再発防止用に、失敗していたケースを再現するテストを `unittest/` か `combined/` のどちらかに 1 本追加（「この入力でこの結果になる」を固定）。

## 4. 既存構成の役割

- **`unittest/`**  
  プラグイン単体のテストのみ。新機能が「新しいプラグイン種別」なら `test_<種別>.py` を追加。新機能が「既存モジュールの新関数」なら、既存の `test_<モジュール>.py` に `test_*` を足すか、モジュールが大きければ `test_<サブ>.py` に分ける。

- **`combined/`**  
  CLI 実行・branch/tag 間の一致の検証。新オプション（`-r`, `--reshape`, `--assess_cages` など）を実装したら、そのオプションを使うケースを 1 つずつ追加。

- **ルートの `make test`**  
  `make -C tests all` で、unittest + combined + その他が一括で回る。新しくテストディレクトリを増やす場合は、`tests/Makefile` の `all` から呼ぶ。

## 5. あると便利な共通基盤（任意）

- **`tests/conftest.py`**  
  プロジェクトルートや `tests/` に 1 つ置き、`genice.x` のパス・サンプルファイルを生成する fixture・一時ディレクトリの fixture などをまとめておく。新しい `test_*.py` を書くたびに「どこで genice を叩くか」「どこにファイルを置くか」を繰り返さずに済む。

- **pytest の設定**  
  `pyproject.toml` の `[tool.pytest.ini_options]` で、`testpaths = ["tests"]`、`python_files = ["test_*.py"]`、必要なら `addopts = "-v"` や `--tb=short` を指定しておくと、`pytest` 一発で現在のテストが全部走り、運用しやすい。

## まとめ

- **新機能ごとにやること**: その機能の「核」は **unittest** に `test_*.py` で書く。CLI やオプション・フォーマットは **combined** に 1 ケースずつ足す。バグ修正は「再発防止の 1 テスト」を必ず足す。
- **命名と配置**: `test_<対象>_<条件>.py` / `test_<対象>_<条件>()`、1 テスト 1 主張、重い準備は fixture。
- **運用**: 上記チェックリストを「新機能追加時のルール」として守り、`make test` で全部回るようにしておく。
