import sys
from logging import getLogger
from io import TextIOWrapper
from typing import Dict, List, Any, Tuple
from collections import defaultdict

import numpy as np

from cif2ice import cellshape, cellvectors
from genice3.molecule import Molecule
from genice3.genice import GenIce3
from genice3.exporter import (
    parse_guest_option,
    parse_spot_guest_option,
    parse_water_model_option,
)
from genice3.cli.pool_parser import (
    parse_options_generic,
    OPTION_TYPE_STRING,
    OPTION_TYPE_KEYVALUE,
)


def _to_lammps_data(
    cellmat: np.ndarray,
    waters: Dict[int, Molecule],
    guests: List[Molecule],
    ions: Dict[int, Molecule],
    command_line: str = None,
) -> str:
    """Output in LAMMPS data format.

    parametersには、hooksで指定したstageの結果が含まれる。
    """
    logger = getLogger("_to_lammps_data")
    logger.info("Generating LAMMPS data file... (Yet to be verified)")

    # セル行列をLAMMPS形式に変換
    # LAMMPSは直交座標系を前提とするため、必要に応じて変換
    if cellmat[0, 1] != 0 or cellmat[0, 2] != 0 or cellmat[1, 2] != 0:
        logger.info(
            "  The specified reshaping matrix does not obey the requirements for LAMMPS' unit cell convention."
        )
        a, b, c, A, B, C = cellshape(cellmat)
        rotmat = np.linalg.inv(cellmat) @ cellvectors(a, b, c, A, B, C)
        logger.info("  The reshape matrix is reoriented.")
    else:
        rotmat = np.eye(3)

    # 分子種ごとにソートする必要がある。
    molecules = defaultdict(list)
    for water in waters.values():
        molecules[water.name].append(water)
    for guest in guests:
        molecules[guest.name].append(guest)
    for ion in ions.values():
        molecules[ion.name].append(ion)

    # 原子タイプのマッピングを作成
    atom_types = {}
    type_counter = 1
    for mol_name in sorted(molecules.keys()):
        mols = molecules[mol_name]
        if len(mols) > 0:
            # 各分子の原子ラベルを取得してタイプを割り当て
            sample_mol = mols[0]
            for label in sample_mol.labels:
                type_key = f"{mol_name}_{label}"
                if type_key not in atom_types:
                    atom_types[type_key] = type_counter
                    type_counter += 1

    # 原子リストを作成
    atoms = []
    molecule_id = 1
    for mol_name in sorted(molecules.keys()):
        mols = molecules[mol_name]
        for mol in mols:
            for name, position in zip(mol.labels, mol.sites):
                type_key = f"{mol_name}_{name}"
                atom_type = atom_types[type_key]
                atoms.append([molecule_id, atom_type, name, position])
            molecule_id += 1

    # セル行列を回転
    cellmat = cellmat @ rotmat

    # LAMMPSデータファイル形式で出力
    s = ""
    if command_line:
        s += f"# {command_line}\n"
    s += "# Generated by GenIce https://github.com/vitroid/GenIce\n"
    s += f"\n{len(atoms)} atoms\n"
    s += f"{len(atom_types)} atom types\n"

    # ボックスサイズを計算
    # LAMMPSは直交座標系を前提とする
    # セルの原点を(0,0,0)として、各軸の範囲を計算
    xlo, xhi = 0.0, cellmat[0, 0]
    ylo, yhi = 0.0, cellmat[1, 1]
    zlo, zhi = 0.0, cellmat[2, 2]
    s += f"\n0.0 {cellmat[0, 0]:.8f} xlo xhi\n"
    s += f"0.0 {cellmat[1, 1]:.8f} ylo yhi\n"
    s += f"0.0 {cellmat[2, 2]:.8f} zlo zhi\n"
    if not (
        abs(cellmat[1, 0]) < 1e-8
        and abs(cellmat[2, 0]) < 1e-8
        and abs(cellmat[2, 1]) < 1e-8
    ):
        # 非直交セル（tilt形式）
        xy = cellmat[1, 0]
        xz = cellmat[2, 0]
        yz = cellmat[2, 1]
        s += f"{xy:.8f} {xz:.8f} {yz:.8f} xy xz yz\n"

    s += "\nAtoms\n\n"

    # 原子座標をnmからAngstromに変換（LAMMPSは通常Angstromを使用）
    # ただし、unitsコマンドで指定できるので、nmのままでも可
    # ここではnmのまま出力（units realまたはunits metalの場合）
    # 電荷は0.0をデフォルトとする（必要に応じて拡張可能）
    charge = 0.0
    for i, atom in enumerate(atoms):
        mol_id, atom_type, atomname, position = atom
        position = position @ rotmat
        s += f"{i + 1:8d} {mol_id:8d} {atom_type:4d} {charge:10.6f} {position[0]:15.8f} {position[1]:15.8f} {position[2]:15.8f}\n"

    logger.info(f"  Total number of atoms: {len(atoms)}")
    logger.info(f"  Total number of atom types: {len(atom_types)}")
    logger.info(f"  Total number of molecules: {molecule_id - 1}")

    return s


def parse_options(options: Dict[str, Any]) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    """
    lammpsプラグインのオプションを処理

    この関数は、動的プラグインチェーン実行システムから呼び出されます。
    コマンドライン引数や設定ファイルから受け取ったオプションのうち、
    lammpsプラグインが処理すべきオプション（guest, spot_guest, water_model）を
    処理し、それ以外は次のプラグイン（例: moleculeプラグイン）に渡すために返します。

    Args:
        options: オプションの辞書（設定ファイルの値が初期値として含まれる可能性がある）
            - guest: ゲスト分子の指定（例: {"A12": "me", "A14": "et"} または ["A12=me", "A14=et"]）
            - spot_guest: 特定のケージに配置するゲスト分子（例: {"0": "foursite"} または "0=foursite"）
            - water_model: 水分子モデル名（例: "3site", "foursite"）

    Returns:
        (処理したオプション, 処理しなかったオプション) のタプル
        - 処理したオプション: lammpsプラグインが処理したオプション（guest, spot_guest, water_model）
        - 処理しなかったオプション: 次のプラグインに渡すオプション（例: type）

    注意:
        - typeオプションはfoursiteなどのmoleculeプラグインのオプションであり、
          この関数では処理せず、処理しなかったオプションとして返します。
        - water_modelが"foursite"などのmoleculeプラグイン名の場合、
          チェーン実行システムが自動的に該当するmoleculeプラグインを呼び出します。
    """
    # オプションの型定義
    option_specs = {
        "guest": OPTION_TYPE_KEYVALUE,  # "A12=me" または {"A12": "me"} 形式
        "spot_guest": OPTION_TYPE_KEYVALUE,  # "0=foursite" または {"0": "foursite"} 形式
        "water_model": OPTION_TYPE_STRING,  # "3site", "foursite" など
    }

    # parse_options_genericを使用してオプションを処理
    # これにより、guestとspot_guestは辞書形式に変換され、
    # water_modelは文字列として処理されます
    return parse_options_generic(options, option_specs)


def dumps(
    genice: GenIce3,
    guest: dict = {},
    spot_guest: dict = {},
    water_model: str = "3site",
    command_line: str = "",
    name: str = "",  # dummy
):
    """
    LAMMPS形式で出力

    Args:
        genice: GenIce3インスタンス
        guest: ゲスト分子の指定
        spot_guest: 特定のケージに配置するゲスト分子
        water_model: 水分子モデル名
        command_line: コマンドライン文字列
        name: プラグイン名（"lammps"または""）
    """
    logger = getLogger("lammps.dump")
    assert name in {"lammps", ""}
    guest_info = parse_guest_option(guest)
    spot_guest_info = parse_spot_guest_option(spot_guest)
    water_model = parse_water_model_option(water_model)
    waters = genice.water_molecules(water_model=water_model)
    guests = genice.guest_molecules(guests=guest_info, spot_guests=spot_guest_info)
    ions = genice.substitutional_ions()

    return _to_lammps_data(
        cellmat=genice.cell,
        waters=waters,
        guests=guests,
        ions=ions,
        command_line=command_line,
    )


def dump(genice: GenIce3, file: TextIOWrapper = sys.stdout, **options):
    file.write(dumps(genice, **options))
